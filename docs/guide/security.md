# 前端安全

## 有哪些可能引起前端安全的的问题?

* 跨站脚本 (Cross-Site Scripting, XSS): ⼀种代码注⼊⽅式, 为了与 CSS 区分所以被称作 XSS. 早期常⻅于⽹络论坛, 起因是⽹站没有对⽤户的输⼊进⾏严格的限制, 使得攻击者可以将脚本上传到帖⼦让其他⼈浏览到有恶意脚本的⻚⾯
* 跨站点请求伪造（Cross-Site Request Forgeries，CSRF）: 指攻击者通过设置好的陷阱，强制对已完成认证的⽤ 户进⾏⾮预期的个⼈信息或设定信息等某些状态更新，属于被动攻击
* 恶意第三⽅库: ⽆论是后端服务器应⽤还是前端应⽤开发，绝⼤多数时候我们都是在借助开发框架和各种类库进⾏ 快速开发,⼀旦第三⽅库被植⼊恶意代码很容易引起安全问题,⽐如event-stream的恶意代码事件,2018年11⽉21⽇， 名为 FallingSnow的⽤户在知名JavaScript应⽤库event-stream在github Issuse中发布了针对植⼊的恶意代码的疑 问，表示event-stream中存在⽤于窃取⽤户数字钱包的恶意代码

## 前端一些安全措施方法

* 输⼊过滤，前后端都需要，前端的所有输入，对后端来说，不可信的
* 转义 HTML，常⽤的模板引擎，如 doT.js、ejs、FreeMarker 等，对于 HTML 转义通常只有⼀个规则，就是把 & < > " ' / 这⼏个 字符转义掉，确实能起到⼀定的 XSS 防护作⽤
* HTTP-only Cookie: 禁⽌ JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注⼊后也⽆法窃取此 Cookie。
* 验证码：防⽌脚本冒充⽤户提交危险操作。

## CSRF攻击

CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进⼊第三⽅⽹站，在第三⽅⽹站中，向被攻击⽹ 站发送跨站请求。利⽤受害者在被攻击⽹站已经获取的注册凭证，绕过后台的⽤户验证，达到冒充⽤户对被攻击的⽹站 执⾏某项操作的⽬的。

⼀个典型的CSRF攻击有着如下的流程：  

* 受害者登录 a.com ，并保留了登录凭证（Cookie
* 攻击者引诱受害者访问了 b.com
* b.com 向 a.com 发送了⼀个请求： a.com/act=xx 浏览器会默认携带a.com的Cookie
* a.com接收到请求后，对请求进⾏验证，并确认是受害者的凭证，误以为是受害者⾃⼰发送的请求
* a.com以受害者的名义执⾏了act=xx
* 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执⾏了⾃⼰定义的操作

**预防CSRF**  
CSRF的两个特点：  

* CSRF（通常）发⽣在第三⽅域名。
* CSRF攻击者不能获取到Cookie等信息，只是使⽤。  

针对这两点，我们可以专⻔制定防护策略，如下  

* 阻⽌不明外域的访问
  * 同源检测
  * Samesite Cookie
* 提交时要求附加本域才能获取的信息
  * CSRF Token
  * 双重Cookie验证

**同源检测**

* 使⽤Origin Header确定来源域名: 在部分与CSRF有关的请求中，请求的Header中会携带Origin字段,如果Origin存 在，那么直接使⽤Origin中的字段确认来源域名就可以
* 使⽤Referer Header确定来源域名: 根据HTTP协议，在HTTP头中有⼀个字段叫Referer，记录了该HTTP请求的来源地址

**Samesite Cookie属性**  
Google起草了⼀份草案来改进HTTP协议，那就是为Set-Cookie响应头新增Samesite属性，它⽤来标明这个 Cookie是 个“同站 Cookie”，同站Cookie只能作为第⼀⽅Cookie，不能作为第三⽅Cookie，Samesite 有三个属性值:

* Samesite=Strict: 这种称为严格模式，表明这个 Cookie 在任何情况下都不可能作为第三⽅ Cookie
* Samesite=Lax: 这种称为宽松模式，⽐ Strict 放宽了点限制,假如这个请求是这种请求且同时是个GET请求，则这个 Cookie可以作为第三⽅Cookie
* Samesite=None: 网站可以选择显式关闭SameSite属性，将其设为None。不过，前提是必须同时设置Secure属性（Cookie 只能通过 HTTPS 协议发送），否则无效。

**CSRF Token**

* 前端获取Token，⻚⾯提交的请求携带这个Token，服务器验证Token是否正确

**双重Cookie验证**

* 约定的方式，使⽤双重提交Cookie。我们可以要求Ajax和表单 请求携带⼀个Cookie中某一个值

## HTTPS是如何保证安全的?

https是安全版的http，因为http协议的数据都是明⽂进⾏传输的，所以对于⼀些敏感信息的传输就很不安全，HTTPS就 是为了解决HTTP的不安全⽽⽣的。

**对称加密**：即通信的双⽅都使⽤同⼀个秘钥进⾏加解密，⽐如特务接头的暗号，就属于对称加密 对称加密虽然很简单性能也好，但是⽆法解决⾸次把秘钥发给对⽅的问题，很容易被⿊客拦截秘钥。

**⾮对称加密**：

1. 私钥 + 公钥= 密钥对
2. 即⽤私钥加密的数据,只有对应的公钥才能解密,⽤公钥加密的数据,只有对应的私钥才能解密.
3. 因为通信双⽅的⼿⾥都有⼀套⾃⼰的密钥对,通信之前双⽅会先把⾃⼰的公钥都先发给对⽅
4. 然后对⽅再拿着这个公钥来加密数据响应给对⽅,等到到了对⽅那⾥,对⽅再⽤⾃⼰的私钥进⾏解密

⾮对称加密虽然安全性更⾼，但是带来的问题就是速度很慢，影响性能。

**解决方案**  
那么结合两种加密⽅式，将对称加密的密钥使⽤⾮对称加密的公钥进⾏加密，然后发送出去，接收⽅使⽤私钥进⾏解密 得到对称加密的密钥，然后双⽅可以使⽤对称加密来进⾏沟通。

此时⼜带来⼀个问题，中间⼈问题：

如果此时在客户端和服务器之间存在⼀个中间⼈,这个中间⼈只需要把原本双⽅通信互发的公钥,换成⾃⼰的公钥,这样中 间⼈就可以轻松解密通信双⽅所发送的所有数据。

所以这个时候需要⼀个安全的第三⽅颁发证书（CA），证明身份的身份，防⽌被**中间⼈**攻击。

证书中包括：签发者、证书⽤途、使⽤者公钥、使⽤者私钥、使⽤者的HASH算法、证书到期时间等

但是问题来了，如果中间⼈篡改了证书，那么身份证明是不是就⽆效了？这个证明就⽩买了，这个时候需要⼀个新的技 术，数字签名。

数字签名就是⽤CA⾃带的HASH算法对证书的内容进⾏HASH得到⼀个摘要，再⽤CA的私钥加密，最终组成数字签 名。

当别⼈把他的证书发过来的时候,我再⽤同样的Hash算法,再次⽣成消息摘要，然后⽤CA的公钥对数字签名解密,得到CA 创建的消息摘要,两者⼀⽐,就知道中间有没有被⼈篡改了

这个时候就能最⼤程度保证通信的安全了。
